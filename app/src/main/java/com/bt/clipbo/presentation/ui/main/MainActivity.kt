package com.bt.clipbo.presentation.ui.main

import android.Manifest
import android.content.Intent
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.provider.Settings
import android.widget.Toast
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.activity.result.contract.ActivityResultContracts
import androidx.activity.viewModels
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.lifecycle.lifecycleScope
import com.bt.clipbo.data.preferences.UserPreferences
import com.bt.clipbo.presentation.ui.components.RatingDialog
import com.bt.clipbo.presentation.ui.components.RatingViewModel
import com.bt.clipbo.ui.theme.ClipboTheme
import com.bt.clipbo.utils.ServiceCoordinator
import com.bt.clipbo.utils.PermissionHelper
import dagger.hilt.android.AndroidEntryPoint
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import javax.inject.Inject

sealed class Screen {
    data object Navigation : Screen()
    data object History : Screen()
    data object Search : Screen()
    data object Tags : Screen()
    data object Secure : Screen()
    data object Settings : Screen()
}

@AndroidEntryPoint
class MainActivity : ComponentActivity() {

    // Hilt injection
    @Inject lateinit var serviceCoordinator: ServiceCoordinator
    @Inject lateinit var userPreferences: UserPreferences
    @Inject lateinit var permissionHelper: PermissionHelper

    private val ratingViewModel: RatingViewModel by viewModels()
    private var isInitialized = false

    // Permission launchers
    private val notificationPermissionLauncher = registerForActivityResult(
        ActivityResultContracts.RequestPermission()
    ) { isGranted ->
        handleNotificationPermissionResult(isGranted)
    }

    private val overlayPermissionLauncher = registerForActivityResult(
        ActivityResultContracts.StartActivityForResult()
    ) { result ->
        handleOverlayPermissionResult()
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()

        setContent {
            ClipboTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background,
                ) {
                    val ratingState by ratingViewModel.state.collectAsState()
                    val serviceStatus by serviceCoordinator.serviceStatus.collectAsState()

                    // Rating dialog
                    if (ratingState.showDialog) {
                        RatingDialog(
                            onDismiss = { ratingViewModel.hideRatingDialog() },
                            onRate = { ratingViewModel.onRateNow(this@MainActivity) },
                            onLater = { ratingViewModel.onRateLater() },
                        )
                    }

                    // Service status monitoring
                    LaunchedEffect(serviceStatus) {
                        if (serviceStatus.errorMessage != null) {
                            showToast("‚ö†Ô∏è ${serviceStatus.errorMessage}")
                        }
                    }

                    ClipboApp(
                        onStartService = {
                            startServicesWithCoordination()
                        },
                        onStopService = {
                            stopServicesWithCoordination()
                        },
                    )
                }
            }
        }

        // Initialize services
        initializeApp()
    }

    override fun onResume() {
        super.onResume()
        // Service status'unu tekrar kontrol et
        if (isInitialized) {
            lifecycleScope.launch {
                delay(500) // UI settling time
                checkAndUpdateServiceStatus()
            }
        }
    }

    private fun initializeApp() {
        lifecycleScope.launch {
            try {
                // Health check ba≈ülat
                serviceCoordinator.startHealthCheck()

                // Auto-start kontrol√º
                if (userPreferences.autoStartService.first()) {
                    delay(1000) // UI'nin tamamen y√ºklenmesini bekle
                    startServicesWithCoordination()
                }

                isInitialized = true
                showToast("üìã Clipbo hazƒ±r!")

            } catch (e: Exception) {
                showToast("‚ùå Ba≈ülatma hatasƒ±: ${e.message}")
            }
        }
    }

    /**
     * Koordinasyonlu service ba≈ülatma
     */
    private fun startServicesWithCoordination() {
        lifecycleScope.launch {
            try {
                showToast("üöÄ Servisler ba≈ülatƒ±lƒ±yor...")

                // Permission kontrol√º
                if (!checkAllPermissions()) {
                    requestMissingPermissions()
                    return@launch
                }

                // Service'leri koordinasyonlu ba≈ülat
                val result = serviceCoordinator.startServices()

                if (result.isSuccess) {
                    showToast("‚úÖ ${result.getOrNull()}")

                    // Service status debug
                    delay(2000)
                    showToast(serviceCoordinator.getServiceSummary())

                } else {
                    val error = result.exceptionOrNull()
                    showToast("‚ùå Ba≈ülatma hatasƒ±: ${error?.message}")

                    // Retry option
                    showRetryOption()
                }

            } catch (e: Exception) {
                showToast("‚ùå Kritik hata: ${e.message}")
            }
        }
    }

    /**
     * Service durdurma
     */
    private fun stopServicesWithCoordination() {
        lifecycleScope.launch {
            try {
                val result = serviceCoordinator.stopServices()

                if (result.isSuccess) {
                    showToast("‚èπÔ∏è Servisler durduruldu")
                } else {
                    showToast("‚ùå Durdurma hatasƒ±: ${result.exceptionOrNull()?.message}")
                }

            } catch (e: Exception) {
                showToast("‚ùå Durdurma hatasƒ±: ${e.message}")
            }
        }
    }

    /**
     * T√ºm izinleri kontrol et
     */
    private fun checkAllPermissions(): Boolean {
        val statuses = permissionHelper.getAllPermissionStatuses()
        return statuses.values.all { it.isGranted }
    }

    /**
     * Eksik izinleri iste
     */
    private fun requestMissingPermissions() {
        lifecycleScope.launch {
            try {
                // Notification permission (Android 13+)
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                    if (!permissionHelper.hasNotificationPermission().isGranted) {
                        showToast("üì¢ Bildirim izni isteniyor...")
                        notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)
                        return@launch
                    }
                }

                // Overlay permission
                if (!permissionHelper.hasOverlayPermission().isGranted) {
                    showToast("üîÑ Overlay izni isteniyor...")
                    requestOverlayPermission()
                    return@launch
                }

                // Accessibility permission
                if (!permissionHelper.hasAccessibilityPermission().isGranted) {
                    showToast("‚ôø Eri≈üilebilirlik izni gerekli")
                    showAccessibilityPermissionDialog()
                    return@launch
                }

            } catch (e: Exception) {
                showToast("‚ùå ƒ∞zin kontrol√º hatasƒ±: ${e.message}")
            }
        }
    }

    /**
     * Notification permission sonucu
     */
    private fun handleNotificationPermissionResult(isGranted: Boolean) {
        if (isGranted) {
            showToast("‚úÖ Bildirim izni verildi")
            // Bir sonraki izni kontrol et
            requestMissingPermissions()
        } else {
            showToast("‚ö†Ô∏è Bildirim izni reddedildi")
            showPermissionDeniedDialog("bildirim")
        }
    }

    /**
     * Overlay permission isteƒüi
     */
    private fun requestOverlayPermission() {
        try {
            val intent = serviceCoordinator.requestOverlayPermission()
            if (intent != null) {
                overlayPermissionLauncher.launch(intent)
            } else {
                showToast("‚ùå Overlay izni desteklenmiyor")
            }
        } catch (e: Exception) {
            showToast("‚ùå Overlay izni hatasƒ±: ${e.message}")
        }
    }

    /**
     * Overlay permission sonucu
     */
    private fun handleOverlayPermissionResult() {
        if (Settings.canDrawOverlays(this)) {
            showToast("‚úÖ Overlay izni verildi")
            // Bir sonraki izni kontrol et
            requestMissingPermissions()
        } else {
            showToast("‚ö†Ô∏è Overlay izni reddedildi")
            showPermissionDeniedDialog("overlay")
        }
    }

    /**
     * Accessibility permission dialog
     */
    private fun showAccessibilityPermissionDialog() {
        // Bu method UI'de bir dialog g√∂sterebilir
        // ≈ûimdilik basit toast ile
        showToast("‚ôø Eri≈üilebilirlik ayarlarƒ±na y√∂nlendirileceksiniz")

        try {
            val intent = Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS).apply {
                addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            }
            startActivity(intent)
        } catch (e: Exception) {
            showToast("‚ùå Ayarlar a√ßƒ±lamadƒ±: ${e.message}")
        }
    }

    /**
     * ƒ∞zin reddedildi dialog
     */
    private fun showPermissionDeniedDialog(permissionType: String) {
        showToast("‚ö†Ô∏è $permissionType izni olmadan tam i≈ülevsellik saƒülanamaz")

        // Kullanƒ±cƒ±yƒ± app settings'e y√∂nlendir
        lifecycleScope.launch {
            delay(2000)
            try {
                val intent = permissionHelper.getAppSettingsIntent()
                startActivity(intent)
            } catch (e: Exception) {
                showToast("‚ùå Ayarlar a√ßƒ±lamadƒ±")
            }
        }
    }

    /**
     * Retry option g√∂ster
     */
    private fun showRetryOption() {
        showToast("üîÑ 5 saniye sonra tekrar denenecek...")

        lifecycleScope.launch {
            delay(5000)

            val retryResult = serviceCoordinator.retryServiceStart()
            if (retryResult.isSuccess) {
                showToast("‚úÖ Tekrar deneme ba≈üarƒ±lƒ±!")
            } else {
                showToast("‚ùå Tekrar deneme ba≈üarƒ±sƒ±z: ${retryResult.exceptionOrNull()?.message}")
            }
        }
    }

    /**
     * Service status kontrol√º ve g√ºncelleme
     */
    private fun checkAndUpdateServiceStatus() {
        lifecycleScope.launch {
            try {
                // Manual status check
                val summary = serviceCoordinator.getServiceSummary()

                // Debug i√ßin log (production'da kaldƒ±rƒ±labilir)
                if (com.bt.clipbo.BuildConfig.DEBUG) {
                    println(summary)
                }

            } catch (e: Exception) {
                showToast("‚ö†Ô∏è Status kontrol hatasƒ±: ${e.message}")
            }
        }
    }

    /**
     * Toast helper
     */
    private fun showToast(message: String) {
        Toast.makeText(this, message, Toast.LENGTH_SHORT).show()
    }

    /**
     * Long toast helper
     */
    private fun showLongToast(message: String) {
        Toast.makeText(this, message, Toast.LENGTH_LONG).show()
    }

    override fun onDestroy() {
        super.onDestroy()
        // Cleanup
        if (isInitialized) {
            serviceCoordinator.cleanup()
        }
    }
}